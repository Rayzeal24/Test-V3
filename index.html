<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tower Defense - v1</title>
  <style>
    body { margin:0; font-family: system-ui, Arial; background:#0f1220; color:#e8e8f0; }
    #wrap { display:flex; gap:16px; padding:16px; }
    canvas { background:#12162a; border:1px solid #2a3156; border-radius:12px; }
    .panel { width:260px; background:#12162a; border:1px solid #2a3156; border-radius:12px; padding:12px; }
    .row { display:flex; justify-content:space-between; margin:6px 0; }
    button { width:100%; padding:10px; border-radius:10px; border:1px solid #2a3156; background:#1a2040; color:#fff; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .hint { font-size:12px; opacity:.85; line-height:1.35; margin-top:10px; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #2a3156; border-radius:999px; font-size:12px; opacity:.9; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="720" height="480"></canvas>
    <div class="panel">
      <div class="row"><strong>Tower Defense</strong> <span class="badge">v1</span></div>
      <div class="row"><span>Vague</span><span id="wave">1</span></div>
      <div class="row"><span>Or</span><span id="gold">120</span></div>
      <div class="row"><span>Base HP</span><span id="basehp">20</span></div>
      <hr style="border-color:#2a3156; opacity:.6"/>
      <div class="row"><span>Tour (coût)</span><span>50</span></div>
      <button id="startWave">Lancer la vague</button>
      <button id="clear" style="margin-top:8px;">Réinitialiser</button>

      <div class="hint">
        - Clique sur une case vide pour poser une tour (pas sur le chemin).<br/>
        - Les tours tirent automatiquement.<br/>
        - Chaque ennemi tué donne de l’or.<br/>
        - Si un ennemi atteint la base, tu perds 1 HP.
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Canvas & UI
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const uiWave = document.getElementById("wave");
  const uiGold = document.getElementById("gold");
  const uiBaseHp = document.getElementById("basehp");
  const btnStart = document.getElementById("startWave");
  const btnClear = document.getElementById("clear");

  // ====== Grid
  const tile = 40;
  const cols = Math.floor(canvas.width / tile);   // 18
  const rows = Math.floor(canvas.height / tile);  // 12

  // Simple path (list of grid points). Enemy will follow these waypoints.
  const path = [
    {x:0,y:5},{x:4,y:5},{x:4,y:2},{x:10,y:2},{x:10,y:9},{x:16,y:9},{x:17,y:9}
  ];

  const isOnPath = (gx, gy) => {
    // Mark tiles along the polyline segments
    for (let i=0;i<path.length-1;i++){
      const a = path[i], b = path[i+1];
      if (a.x===b.x){
        const x=a.x;
        const y0=Math.min(a.y,b.y), y1=Math.max(a.y,b.y);
        if (gx===x && gy>=y0 && gy<=y1) return true;
      } else if (a.y===b.y){
        const y=a.y;
        const x0=Math.min(a.x,b.x), x1=Math.max(a.x,b.x);
        if (gy===y && gx>=x0 && gx<=x1) return true;
      }
    }
    return false;
  };

  const gridToPxCenter = (gx, gy) => ({
    x: gx*tile + tile/2,
    y: gy*tile + tile/2
  });

  // ====== Game state
  let gold = 120;
  let baseHp = 20;
  let wave = 1;
  let runningWave = false;

  const towers = [];
  const enemies = [];
  const bullets = [];

  // ====== Entities
  const TOWER_COST = 50;

  function spawnEnemy(i) {
    const start = gridToPxCenter(path[0].x, path[0].y);
    enemies.push({
      x: start.x,
      y: start.y,
      speed: 55 + wave*2,      // px/s
      hp: 30 + wave*8,
      maxHp: 30 + wave*8,
      waypoint: 1,
      radius: 12,
      reward: 12 + Math.floor(wave*2)
    });
  }

  function addTower(gx, gy) {
    const c = gridToPxCenter(gx, gy);
    towers.push({
      gx, gy,
      x: c.x, y: c.y,
      range: 120,
      fireRate: 0.55,  // shots/s
      cooldown: 0,
      damage: 12 + Math.floor(wave*0.5)
    });
  }

  function shoot(tower, target) {
    const dx = target.x - tower.x;
    const dy = target.y - tower.y;
    const dist = Math.hypot(dx, dy) || 1;
    const speed = 260; // px/s
    bullets.push({
      x: tower.x, y: tower.y,
      vx: (dx/dist)*speed,
      vy: (dy/dist)*speed,
      dmg: tower.damage,
      radius: 4
    });
  }

  // ====== Wave control
  function startWave() {
    if (runningWave || baseHp<=0) return;
    runningWave = true;
    btnStart.disabled = true;

    const count = 8 + wave*2;
    let spawned = 0;
    const interval = setInterval(() => {
      if (spawned >= count) { clearInterval(interval); return; }
      spawnEnemy(spawned);
      spawned++;
    }, 420);

    // End wave when all enemies are done (killed or reached base)
    const checkEnd = setInterval(() => {
      const stillSpawning = spawned < count;
      if (!stillSpawning && enemies.length === 0) {
        clearInterval(checkEnd);
        runningWave = false;
        wave++;
        uiWave.textContent = wave;
        btnStart.disabled = false;
      }
      if (baseHp<=0){
        clearInterval(checkEnd);
        runningWave = false;
        btnStart.disabled = true;
      }
    }, 300);
  }

  // ====== Input
  canvas.addEventListener("click", (e) => {
    if (baseHp<=0) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const gx = Math.floor(mx / tile);
    const gy = Math.floor(my / tile);

    if (isOnPath(gx, gy)) return;
    if (towers.some(t => t.gx===gx && t.gy===gy)) return;
    if (gold < TOWER_COST) return;

    gold -= TOWER_COST;
    uiGold.textContent = gold;
    addTower(gx, gy);
  });

  btnStart.addEventListener("click", startWave);
  btnClear.addEventListener("click", () => location.reload());

  // ====== Update loop
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    update(dt);
    render();

    requestAnimationFrame(tick);
  }

  function update(dt) {
    // Enemies move along waypoints
    for (let i=enemies.length-1;i>=0;i--){
      const en = enemies[i];
      const wp = path[en.waypoint];
      if (!wp) { // reached end
        enemies.splice(i,1);
        baseHp -= 1;
        uiBaseHp.textContent = baseHp;
        continue;
      }
      const p = gridToPxCenter(wp.x, wp.y);
      const dx = p.x - en.x;
      const dy = p.y - en.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 2) {
        en.waypoint++;
      } else {
        const ux = dx / (dist || 1);
        const uy = dy / (dist || 1);
        en.x += ux * en.speed * dt;
        en.y += uy * en.speed * dt;
      }
    }

    // Towers acquire targets + shoot
    for (const t of towers){
      t.cooldown -= dt;
      if (t.cooldown > 0) continue;

      // nearest enemy in range
      let best = null;
      let bestD = Infinity;
      for (const en of enemies){
        const d = Math.hypot(en.x - t.x, en.y - t.y);
        if (d <= t.range && d < bestD){
          bestD = d;
          best = en;
        }
      }
      if (best){
        shoot(t, best);
        t.cooldown = 1 / t.fireRate;
      }
    }

    // Bullets move + collide
    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // remove if out of bounds
      if (b.x < -20 || b.y < -20 || b.x > canvas.width+20 || b.y > canvas.height+20){
        bullets.splice(i,1);
        continue;
      }

      // hit test
      let hitIndex = -1;
      for (let j=0;j<enemies.length;j++){
        const en = enemies[j];
        const d = Math.hypot(en.x - b.x, en.y - b.y);
        if (d <= en.radius + b.radius){
          hitIndex = j;
          en.hp -= b.dmg;
          break;
        }
      }
      if (hitIndex !== -1){
        bullets.splice(i,1);
        const en = enemies[hitIndex];
        if (en.hp <= 0){
          gold += en.reward;
          uiGold.textContent = gold;
          enemies.splice(hitIndex,1);
        }
      }
    }
  }

  // ====== Render
  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Grid
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = "#2a3156";
    for (let x=0;x<=cols;x++){
      ctx.beginPath();
      ctx.moveTo(x*tile, 0);
      ctx.lineTo(x*tile, canvas.height);
      ctx.stroke();
    }
    for (let y=0;y<=rows;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*tile);
      ctx.lineTo(canvas.width, y*tile);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Path tiles
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        if (!isOnPath(x,y)) continue;
        ctx.fillStyle = "#1b2448";
        ctx.fillRect(x*tile, y*tile, tile, tile);
      }
    }

    // Base (end)
    const end = path[path.length-1];
    const base = gridToPxCenter(end.x, end.y);
    ctx.fillStyle = "#2b376b";
    ctx.beginPath();
    ctx.arc(base.x, base.y, 16, 0, Math.PI*2);
    ctx.fill();

    // Towers
    for (const t of towers){
      ctx.fillStyle = "#3a4bb0";
      ctx.beginPath();
      ctx.arc(t.x, t.y, 14, 0, Math.PI*2);
      ctx.fill();

      // little barrel
      ctx.strokeStyle = "#aab2ff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(t.x, t.y);
      ctx.lineTo(t.x+10, t.y);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // Enemies
    for (const en of enemies){
      ctx.fillStyle = "#d05c5c";
      ctx.beginPath();
      ctx.arc(en.x, en.y, en.radius, 0, Math.PI*2);
      ctx.fill();

      // HP bar
      const w = 28, h = 4;
      const ratio = Math.max(0, en.hp / en.maxHp);
      ctx.fillStyle = "#00000066";
      ctx.fillRect(en.x - w/2, en.y - en.radius - 10, w, h);
      ctx.fillStyle = "#ffffffcc";
      ctx.fillRect(en.x - w/2, en.y - en.radius - 10, w*ratio, h);
    }

    // Bullets
    for (const b of bullets){
      ctx.fillStyle = "#f2f2ff";
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
      ctx.fill();
    }

    // Game over
    if (baseHp <= 0){
      ctx.fillStyle = "#000000aa";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.font = "28px system-ui";
      ctx.fillText("Game Over", canvas.width/2 - 80, canvas.height/2);
      ctx.font = "14px system-ui";
      ctx.fillText("Clique sur Réinitialiser pour rejouer", canvas.width/2 - 120, canvas.height/2 + 26);
    }
  }

  // Init UI
  uiWave.textContent = wave;
  uiGold.textContent = gold;
  uiBaseHp.textContent = baseHp;

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
